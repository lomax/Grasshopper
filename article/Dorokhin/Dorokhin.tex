\addcontentsline{etoc}{chapter}{\textit{Dorokhin S.\,V., Kachkov S.\,S., Sidorenko A.\,A} Implementation of Kuznyechik cipher using vector instructions}

\begin{abstract}
Целью данной работы является создание оптимизированной программной реализации блочного шифра ГОСТ Р 34.12 2015, известного как <<Кузнечик>>.
В ходе исследования был проведён анализ возможных средств улучшения скорости работы шифра. Основное внимание уделено использованию SIMD (Single Instruction Multiple Data) инструкций
и учёту общедоступной информации об устройстве Execution Engine процессоров Intel\textregistered Core\textsuperscript{TM} поколения Sandy Bridge и новее. 
Отличительной особенностью статьи является то,
что в ней представлены измерения скорости зашифрования и расшифрования в режимах ECB, CBC, CFB, OFB на процессорах четырёх различных поколений (включая Kaby Lake R), 
в открытом доступе выложен исходный код высокоскоростной реализации и скриптового интерфейса для автоматического тестирования. Для дальнейшего ускорения используется набор команд AVX2. 
Предлагается использование 256-битных регистров для ускорения зашифрования и расшифрования в режиме ECB, расшифрования в режиме CFB.
\kwr ГОСТ Р 34.12 2015, высокоскоростная реализация, LSX-преобразование, блочный шифр, SSE, AVX.

\blfootnote{\hspace{-7pt}\textcopyright \, Dorokhin S.\,V., Kachkov S.\,S., Sidorenko A.\,A. 2018\\ \indent\textcopyright \, Федеральное государственное автономное образовательное учреждение высшего образования\\
\indent\hspace{15pt}<<Московский физико-технический институт
(государственный университет)>>, 2018}

\end{abstract}

\arthead{S.\,V. Dorokhin$^{1, 2}$, S.\,S. Kachkov$^{1, 3}$, A.\,A. Sidorenko$^{1, 3}$}
{$^{1}$Moscow Institute of Physics and Technology\par
 $^{2}$JSC "Milandr"\par
 $^{3}$JSC "Intel"\par}
{Implementation of Kuznyechik cipher using vector instructions}

\begin{abstract}
This article is concentrated on highly-optimized implementation of block cipher GOST R 34.12 2015, also known as Kuznyechik. A comparative analysis of possible imporvements is presented,
with the SIMD (Single Instruction Multiple Data) instructions being in focus. The publicly available information about Intel\textregistered Core\textsuperscript{TM} Execution Engine (starting 
with Sandy Bridge) was taken into consideration. AVX2 instruction set gets our special attention. 
The key feature of the article is that a cutting-edge open-source implementation is presented. The abovementioned implementation allows to compare 4 modes of operation,
such as ECB, CBC, CFB and OFB. The results in this paper are given for 4 modern generations of Intel\textregistered Core\textsuperscript{TM} line (with Kaby Lake R being the newest one).
We also suggest using 256-bit ymm registers and AVX2 instruction set to boost ECB mode encryption \& decryption and CFB mode decryption.
\kwe GOST R 34.12 2015, high-speed implementation, LSX-transform, block cipher, SSE, AVX.
\end{abstract}
\bigskip

\section{Введение}
<<Кузнечик>> представляет собой блочный шифр с размером блока 128 бит. Обозначим множество всевозможных двоичных строк длинны s как $V_{s}$. Алгоритм зашифрования сводится к последовательному применению следующих операций: 
\begin{itemize}
\item Побитовая операция сложения по модулю 2: $X[k](a) = k \oplus a$, где $k, a \in V_{128}$;
\item Биективное нелинейное преобразование: $S(a) = S(a_{15}||...||a_{0}) = \pi(a_{15})||...||\pi(a_{0})$, где $a_{i} \in V_{8}$, символом $||$ обозначена операция конкатенации, a $\pi:V_{8} \to V_{8}$ -- некоторая известная подстановка;
\item Линейное преобразование: $L: V_{128} \to V_{128}$.
\end{itemize}
С учётом этих обозначений функции зашифрования $E(a)$ и расшифрования $D(a)$, $a \in V_{128}$ могут быть представлены в следующем виде:\\*
\begin{equation}
\label{encrypt}
E_{k_{1},...,k_{10}}(a) = X[k_{10}]LSX[k_{9}]...LSX[k_{2}]LSX[k_{1}](a);
\end{equation}
\begin{equation}
\label{decrypt}
D_{k_{1},...,k_{10}}(a) = X[k_{1}]S^{-1}L^{-1}X[k_{2}]...S^{-1}L^{-1}X[k_{9}]S^{-1}L^{-1}X[k_{10}](a),
\end{equation}
где $k_{1}$, ... $k_{10}$ -- раундовые ключи. Эти ключи вырабатываются один раз в начале алгоритма, вычисляются также с помощью $X$, $S$, и $L$ преобразований
 и не оказывают существенного влияния на скорость работы шифра, поэтому в рамках статьи алгоритм развёртывания ключа не обсуждается.
Здесь и далее раундовые ключи предполагаются уже вычисленными.
Линейное преобразование L может быть осуществленно с помощью 16 циклов работы РСЛОС (регистра сдвига с линейной обратной связью), показанного на рис. 1.
Под умножением подразумевается умножение над полем Галуа по модулю неприводимого многочлена $p(x) = x^{8} + x^{7} + x^{6} + x + 1$.
\begin{figure}[h!] \centering
\includegraphics[height=0.2\textheight, width=16cm, height=4cm]{Dorokhin1.jpg}
\caption{РСЛОС, реализующий L-преобразование}
\end{figure}

Такое решение является предпочтительным при аппаратной реализации шифра, однако при создании программной реализации удобнее представить $L$-преобразование в матричной форме. Результат работы одного такта РСЛОС можно записать в виде

$$
\begin{pmatrix} a_{n-1}^{*} \\ a_{n-2}^{*} \\ a_{n-3}^{*} \\ \vdots \\ a_{1}^{*} \\  a_{0}^{*} \end{pmatrix}
=
\left(\begin{array}{ccccccc}
c_{n-1} & c_{n-2} & c_{n-3} &\hdots & c_{2}  & c_{1}   & c_{0} \\
1       & 0       & 0       &\hdots & 0      & 0       & 0 \\
0       & 1       & 0       &\hdots & 0      & 0       & 0 \\
\vdots  & \ddots  & \ddots  &\ddots &\ddots  &\ddots   & \vdots \\
0       & 0       & 0       &\hdots & 1      &0        & 0 \\
0       & 0       & 0       &\hdots & 0      &1        & 0
\end{array}\right)
\cdot
\begin{pmatrix} a_{n-1} \\ a_{n-2} \\ a_{n-3} \\ \vdots  \\ a_{1} \\ a_{0} \end{pmatrix},
$$
где $a_{i}^{*}$ -- новые компоненты вектора. Результат работы после k тактов:

\begin{equation}
\label{lmatrix}
\begin{pmatrix} a_{n-1}^{*} \\ a_{n-2}^{*} \\ a_{n-3}^{*} \\ \vdots \\ a_{1}^{*} \\  a_{0}^{*} \end{pmatrix}
=
\left(\begin{array}{ccccccc}
c_{n-1} & c_{n-2} & c_{n-3} &\hdots & c_{2}  & c_{1}   & c_{0} \\
1       & 0       & 0       &\hdots & 0      & 0       & 0 \\
0       & 1       & 0       &\hdots & 0      & 0       & 0 \\
\vdots  & \ddots  & \ddots  &\ddots &\ddots  &\ddots   & \vdots \\
0       & 0       & 0       &\hdots & 1      &0        & 0 \\
0       & 0       & 0       &\hdots & 0      &1        & 0
\end{array}\right)^{\!k}
\cdot
\begin{pmatrix} a_{n-1} \\ a_{n-2} \\ a_{n-3} \\ \vdots  \\ a_{1} \\ a_{0} \end{pmatrix},
\end{equation}

Применение L-преобразования в такой форме существенно быстрее, чем при моделировании РСЛОС. Однако профилирование программы 
при помощи утилиты callgrind показало, что на L преобразование приходится приблизительно 75\% \begin{comment} проверить! \end{comment}
времени исполнения программы. Следуя принципу make common case fast, необходимо оптимизировать именно L-преобразование, чему, по существу, и посвящена эта статья. 
\section{Обзор существующих методов}
Так как большую часть работы программы занимает L-преобразование, оптимизация операций зашифрования и расшифрования сводится к оптимизации умножения вектора на матрицу в конечном поле.
Для ускорения этой операции общепринятым является использование таблиц предвычислений (LUT, Lookup Table).
\subsection{Построение LUT}
Особенностям построения таких таблиц уделено должное внимание в \cite{s2}. Для полноты изложения кратко приведём рассуждения из указанной статьи. 
Вычисляется матрица уравнения \eqref{lmatrix} для случая k = 16. Определим для i-того столбца полученной матрицы отображение $L_{i}(b): V_{8} \to V_{128}$ такое, что
\[
L_{i}(b) = c_{i, 15}\cdot b \: || \: c_{i, 14}\cdot b \: || \: \hdots \: || \: c_{i, 0}\cdot \: b, \; b \in V_{8}.
\] 
Тогда L-преобразование может быть представлено в виде
\[
L(a) = L_{15}(a_{15})\oplus L_{14}(a_{14}) \oplus \hdots \oplus L_{1}(a_{1}) \oplus L_{0}(a_{0}).
\]
LUT имеет размер 16x256, каждый элемент таблицы является блоком данных из 16 байт и строится по следующему принципу: LUT$[i][j]$ есть результат покомпонентого умножения j-того байта исходного вектора на i-ый столбец матрицы L-преобразования.
Таким образом, для осуществления LS-преобразования над блоком необходимо произвести сложения по модулю 2 всех 16 блоков из LUT.
\subsection{Объединение $S$ и $L$ преобразования}
Определим теперь преобразование $L_{i}^{'}: V_{8} \to V_{128}, /; i = 0, ..., 15$ как
\[
L_{i}^{'}(b) = c_{i,15} \cdot \pi(b) || c_{i,14} \cdot \pi(b)||\hdots||c_{i,0} \cdot \pi(b), b \in V_{8}.   
\]
Тогда композицию $L$ и $S$ преобразований можно представить в виде
\[
LS(a) = L_{15}^{'}(a_{15}) \oplus L_{14}^{'}(a_{14}) \oplus \hdots \oplus L_{0}^{'}(a_0),
\]
то есть строится таблица предвычислений, по структуре аналогичная предыдущему пункту. Отличие заключается в том, что $L$ и $S$ преобразования объединены в одно. 
Теперь не составляет труда реализовать все три базовые преобразования из \eqref{encrypt} как одно $XSL$ преобразование: 

\begin{lstlisting}[language=c++, caption={XSL-преобразование с использованием LUT}]
void Grasshopper::ApplyXSL(Block& data, const Block& key)
{
    ApplyX(data, key);
    Block tmp{};
    for (size_t i = 0; i < block_size; i++)
        ApplyX(tmp, enc_ls_table[i][data[i]]);
    data = tmp;
}
\end{lstlisting}

\subsection{LUT для $L^{-1}S^{-1}$} 
Особенности построения LUT для обратного преобразования связанно с тем, что в уравнении \eqref{decrypt} преобразование $L$ применяется перед $S$. Решение этой проблемы может быть найдено в \cite{s2}. А именно, преобразуем это уравнение:
\begin{multline}
\label{decr_mod}
D_{k_{1},...,k_{10}}(a) = X[k_{1}]S^{-1}L^{-1}X[k_{2}]...S^{-1}L^{-1}X[k_{9}]S^{-1}L^{-1}X[k_{10}](a) = \\
= X[k_{1}]S^{-1}L^{-1}X[k_{2}]...S^{-1}L^{-1}X[k_{9}]S^{-1}L^{-1}X[k_{10}]S^{-1}S(a)
\end{multline}
С учётом линейности L-преобразования
\begin{multline}
\label{lin}
L^{-1}X[k_{i}]S^{-1}(a) = L^{-1}(S^{-1}(a) \oplus k_{i}) = L^{-1}(S^{-1}(a)) \oplus L^{-1} (k_{i}) = L^{-1}S^{-1}(a) \oplus L^{-1}(k_{i}) =\\
= X[L^{-1}(k_{i})]L^{-1}S^{-1}(a)
\end{multline}

Применяя \eqref{lin} к \eqref{decr_mod}, получим:
\begin{multline}
\label{final-L-S}
D_{k_{1},...,k_{10}}(a) = X[k_{1}]S^{-1}L^{-1}X[k_{2}]...S^{-1}L^{-1}X[k_{9}]S^{-1}L^{-1}X[k_{10}]S^{-1}S(a) = \\
= X[k_{1}]S^{-1}(L^{-1}X[k_{2}]S^{-1})\hdots(L^{-1}X[k_{10}]S^{-1})S(a) = \\
= X[k_{1}]S^{-1}(X[L^{-1}(k_{2}]L^{-1}S^{-1})\hdots(X[L^{-1}(k_{10}]L^{-1}S^{-1})S(a)
\end{multline}
Таким образом, операция зашифрования также может быть сведена к объединённому $XL^{-1}S^{-1}$ преобразованию, реализованному через LUT (в предположении, что значения $L^{-1}(k_{i})$ заданы).
От операции зашифрования операция расшифрования отличается применением дополнительно подстановок $S$ и $S^{-1}$, поэтому расшифрование в режимах ECB и CBC будет заведомо медленнее.
\subsection{Использование векторных инструкций}
Для дальнейшей оптимизации можно использовать 128-битные xmm регистры, размер которых совпадает с размером блока шифра. 
Однако дизассемблирование модифицированной таким образом программы показывает, что цикл, отвечающий за применение склеенного XLS преобразования
содержит дополнительную инструкцию битового сдвига влево:
\begin{lstlisting}[language=Awk, caption={Часть результата дизассемблирования цикла XLS преобразования}]
movzbl 0x3(%rsi),           %eax
shl    $0x4,                %rax
xorps  0x3000(%rdx,%rax,1), %xmm0
\end{lstlisting}
%$
Адрес $A$ в памяти вычисляется по формуле $A = B + I * S + D$, где $B$ -- базовое смещение, $I$ -- индекс, $S$ -- масштаб (scale), $D$ -- смещение (displacement).   
В приведённом коде rdx содержит базовое смещение $B$, rax используется для вычисления смещения $D$. Так как в LUT 16-байтовые вектора хранятся друг за другом, приходится домножать смещение на 16,
используя битовый сдвиг, и передавать результат как $D$. Это смещение нельзя задать, используя $S$, так как $S \in \{ 2, 4, 8 \}$ (см. \cite{s5}). Ещё одна оптимизация заключается в предвычислении смещений в начале цикла
с тем, чтобы не исполнять в дальнейшем операцию битового сдвига, а передавать в качестве memory operand готовое $S$.
Для предвычисления смещений также используются регистры xmm. Из блока данных посредством операций $И$ и $И \: НЕ$ с помощью маски выделяются отдельно чётные и нечётные байты. 
К полученным после применения $И$ и $И \: НЕ$ блокам применяются операции битового сдвига на 4 вправо (srli) и влево (slli) соответственно (см. рис. 2) с тем, чтобы считывать двубайтные блоки с отступом в 4 байта от начала
(то есть кратные шестнадцати значения). 

\begin{figure}[h!] \centering
\includegraphics[height=0.2\textheight, width=16cm, height=8.6cm]{Dorokhin2.jpg}
\caption{Предвычисление смещений}
\end{figure}

В \cite{s1} приведено описание этой модификации. В частности, указано, что следует учитывать особенности планировшика. 
В \cite{s4} упоминается, что, к примеру, микроархитектура Intel Sandy Bridge имеет в своём распоряжении 2 исполнительных устройства для вычисления адреса (AGU - address generation unit),
а также 3 ALU (arithmetic and logic unit), способные производить операции над векторными регистрами. Чтобы помочь планировщику выполнять загрузки блока из таблицы и суммирование по модулю 2 с результатом параллельно, 
можно использовать чередование регистров в этих командах (подробное описание использованных функций можно найти в \cite(s5):
\begin{lstlisting}[language=C++, caption={LS-преобразование с использованием чередования регистров}]
__m128i vec1 = _mm_load_si128(reinterpret_cast<const __m128i*>(table+_mm_extract_epi16(tmp2, 0)+0x0000));
__m128i vec2 = _mm_load_si128(reinterpret_cast<const __m128i*>(table+_mm_extract_epi16(tmp1, 0)+0x1000));

vec1 = _mm_xor_si128(vec1, CastBlock(table+_mm_extract_epi16(tmp2, 1)+0x2000));
vec2 = _mm_xor_si128(vec2, CastBlock(table+_mm_extract_epi16(tmp1, 1)+0x3000));

vec1 = _mm_xor_si128(vec1, CastBlock(table+_mm_extract_epi16(tmp2, 2)+0x4000));
vec2 = _mm_xor_si128(vec2, CastBlock(table+_mm_extract_epi16(tmp1, 2)+0x5000));
...
vec1 = _mm_xor_si128(vec1, CastBlock(table+_mm_extract_epi16(tmp2, 7)+0xE000));
vec2 = _mm_xor_si128(vec2, CastBlock(table+_mm_extract_epi16(tmp1, 7)+0xF000));
data = _mm_xor_si128(vec1, vec2);
\end{lstlisting}
Предвычисление инструкций, которе было описано на рис. 2:
\begin{lstlisting}[language=Awk, caption={Результат дизассемблирования предвычисления смещений}]
movdqa (%rsi),%xmm1
movdqa %xmm1,%xmm0
psrlq  $0x4,%xmm0
psllq  $0x4,%xmm1
movdqa 0x1876(%rip),%xmm2 
pand   %xmm2,%xmm0
pextrw $0x0,%xmm0,%eax
pand   %xmm2,%xmm1
0x1000(%rdx,%rax,1),%xmm2
\end{lstlisting}
Эти предварительные вычисления позволяют вычислять xor за две операции:
\begin{lstlisting}[language=Awk, caption={Операция xor для случая с предвычислением}]
pextrw $0x0,%xmm1,%eax
xorps  (%rdx,%rax,1),%xmm2
pextrw $0x1,%xmm1,%eax
xorps  0x2000(%rdx,%rax,1),%xmm2
pextrw $0x1,%xmm0,%eax
xorps  0x3000(%rdx,%rax,1),%xmm2
...
\end{lstlisting}
В статье \cite{s1} авторы пришли к заключению, что скорость работы <<Кузнечика>> в реализации с использованием xmm регистров достигла своего предела.
Хороший сравнительный анализ многочисленных вариантов реализации шифра с использованием LUT различных размеров дан в \cite{s3}. 
Из этого анализа следует, что наибольшая скорость работы достигается именно с использованием xmm регистров и LUT размером 64 kB, описанной в этой статье.
Примечательно, что реализация с использованием 256-битных регистров ymm и тем же LUT в 64 kB по результатам этого анализа существенно проигрывает реализации на xmm регистрах.
\section{Использование AVX2 в режимах ECB и CFB}
И всё таки, в отдельных случаях можно получить ускорение за счёт использования б\'ольших по размеру регистров.
Мы предлагаем обрабатывать сразу два блока данных в некоторых режимах шифрования, используя расширенные до 256 бит векторные регистры (расширение набора инструкций AVX2, поддерживаемое с Intel Haswell и AMD Excavator).
Это возможно в тех случаях, когда шифрование (или расшифрование) текущего блока возможно производить независимо от предыдущего. В этой работе были реализованы следующие режимы работы шифра:
\begin{itemize}
    \item ECB (Electronic Codebook)
    \item CBC (Cipher Block Chaining)
    \item CFB (Cipher Feedback)
    \item OFB (Output Feedback)
\end{itemize}
Данная оптимизация была осуществлена для шифрования и расшифрования в режиме ECB и для расшифрования в режиме CFB. 
Попытка использовать ymm регистры непосредственно внутри LSX-преобразования не приводит к желаемому ускорению, так как загрузка 128-битных блоков в половинки регистра ymm занимает слишком много времени.
Поэтому успешко использовать AVX2 для всех режимов не удаётся. Предлагается следующая модификация для режима ECB: 
в половины 256-битного ymm регистра загружается по блоку открытого текста, применяется объединённое LSX-преобразование, аналогичное описанному в разделе 2.4. Различие заключается в том, 
что одним применением LSX-преобразования обрабатывается сразу два блока. Используются аналогичные предвычисления смещений с 256-битной маской (см. рис. 3)
\begin{figure}[h!] \centering
\includegraphics[height=0.2\textheight, width=16cm, height=4.8cm]{Dorokhin3.jpg}
\caption{Предвычисление смещений для модификации с AVX2}
\end{figure}
Здесь синим цветом показаны байты, относящиеся к смещению второго блока, srli и slli обозначают побитовый сдвиг на 4 бита вправо и влево соответственно. 
Два ymm регистра инициализируются в начале цикла и накапливают результат xor один для чётных, другой для нечётных байт. Ещё два ymm регистра необходимы, чтобы загружать в них данные на каждой итерации,
выполнять xor с накапливающими регистрами и сохранять в эти регистры промежуточный результат: 
\begin{lstlisting}[language=C++, caption={Использование AVX2 в режиме ECB}]
    ...
    data = _mm256_inserti128_si256(data, table+_mm256_extract_epi16(tmp2, 0)+0x0000, 0);
    data = _mm256_inserti128_si256(data, table+_mm256_extract_epi16(tmp2, 8)+0x0000, 1);

    vec2 = _mm256_inserti128_si256(vec2, table+_mm256_extract_epi16(tmp2, 1)+0x2000, 0);
    vec2 = _mm256_inserti128_si256(vec2, table+_mm256_extract_epi16(tmp2, 9)+0x2000, 1);

    vec1 = _mm256_inserti128_si256(vec1, table+_mm256_extract_epi16(tmp1, 0)+0x1000, 0);
    vec1 = _mm256_inserti128_si256(vec1, table+_mm256_extract_epi16(tmp1, 8)+0x1000, 1);
    
    vec3 = _mm256_inserti128_si256(vec3, table+_mm256_extract_epi16(tmp1, 1)+0x3000, 0);
    vec3 = _mm256_inserti128_si256(vec3, table+_mm256_extract_epi16(tmp1, 9)+0x3000, 1);

    data = _mm256_xor_si256(data, vec2);
    vec1 = _mm256_xor_si256(vec1, vec3);
    ...
\end{lstlisting}
В данном случае data и vec1 выступают в качестве накапливающих регистров для xor чётных и нечётных байт соответсвенно. Такая схема позволяет учитывать особенности планировщика так же, как и в пункте 2.4. Однако
LSX-преобразование ускорится заведомо меньше, чем в два раза, из-за расходов на загрузку блоков в ymm регистры и из-за ограниченного количества AGU (не более 3 штук). Аналогичным образом ускоряется расшифрование. 
Такую же идею можно применить для расшифрования в режиме CFB.

\section{Сравнительный анализ}
В заключение приведём результаты для различных степеней оптимизации и различных процессоров (таблицы 1, 2). Под baseline подразумевается реализация c L-преобразованием через сдвиговый регистр;
with LUT -- реализация, в которой L-преобразование выполнено при помощи LUT, но без использования xmm-регистров; LUT, xor -- аналогично, но предвычисляется уже LS-преобразование,
LSX объединено в одну функцию; offset -- использование xmm регистров и предвычисления смещений; AVX2 -- описанная в пункте 3 модификация.  

\begin{table}[h!]
\begin{flushright}
{Т а б л и ц а 1}\\
\centering
\textbf{Скорость шифрования в режиме ECB, Mb/s}
\end{flushright}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
Реализация & i3-4030u   & i5-5200u & i5-7200u & i5-8250u  \\ 
Baseline & 6          & 8,8      & 10,2     & 11,4      \\ \hline
With LUT & 53         & 77       & 99       & 107       \\ \hline
LUT, xor & 69         & 99       & 131      & 139       \\ \hline
Offset   & 79         & 113      & 135      & 142       \\ \hline
AVX2     & 84         & 121      & 150      & 159       \\ \hline
\end{tabular}
\end{table}

\begin{table}[h!]
\begin{flushright}
{Т а б л и ц а 2}\\
\centering
\textbf{Скорость расшифрования в режиме CFB, Mb/s}
\end{flushright}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
         & i3-4030u   & i5-5200u  & i5-7200u & i5-8250u \\ \hline
Baseline & 5,2        & 8,7       & 10,2     & 9,4      \\ \hline
With LUT & 50         & 73        & 94       & 103      \\ \hline
LUT, xor & 73         & 105       & 131      & 145      \\ \hline
Offset   & 80         & 118       & 135      & 150      \\ \hline
AVX2     & 82         & 120       & 145      & 159      \\ \hline
\end{tabular}
\end{table}

Более того, выбор компилятора тоже немаловажен. В работе \cite{s3} сравнивались результаты, полученные при комплияции с помощью Visual C++, Intel C++ и gcc. Нами было установлено, 
что наибольшая скорость достигается при компиляции clang (см. рис. 4).
\begin{figure}[h!] \centering
\includegraphics[height=0.2\textheight, width=10cm, height=5cm]{Dorokhin4.jpg}
\caption{Сравнение скорости работы (MB/s) при компиляции clang и gcc (i3-4030)}
\end{figure}

\section{Заключение}

В данной статье подробно описаны известные на текущий момент методы оптимизации программной реализации блочного шифра <<Кузнечик>>.
Предложена модификация реализации для режимов ECB и OFB, использующая расширение набора инструкций AVX2. Данная модификация даёт заментый прирост.
Дальнейшее ускорение скорости работы шифра напрямую связано с увеличением производительности процессоров. Похоже, что методы, описанные в этой статье и в \cite{s3}
представляют собой последние программные модификации, ведущие к росту скорости зашифрования и расшифрования. 

\hfil \hbox to 0.3\textwidth{\hrulefill} \smallskip

%Литература
\begin{thebibliography}{99}

\bibitem{s1} \textit{Алексеев Е.\,К., Попов В.\,О., Прохоров А.\,С., Смышляев С.\В., Сонина Л.\,А.} Об эксплуатационных качествах одного перспективного блочного шифра типа LSX // Математические вопросы криптографии.~--- 2015.~--- T.~6, вып.~2.~--- С.~6--17.

\bibitem{s2}  \textit{Бородин М.\,А., Рыбкин А.\,С.}  Высокоскоростные программные реализации блочного шифра Кузнечик // Проблемы информационной безопасности. Компьютерные системы.~--- 
2014.~--- Вып.~3.~--- С.~67--73.

\bibitem{s3} \textit{Рыбкин  А.\,С.} О программной реализации алгоритма Кузнечик на процессорах Intel // Математические вопросы криптографии.~--- 2018.~--- Т.~9, вып.~2.~--- С.~117--127.

\bibitem{s4} Intel\textregistered 64 and IA-32 Architectures Optimization Reference Manual.~--- Intel Corporation, 2016.

\bibitem{s5} Intel\textregistered 64 and IA-32 Architectures Software Developer's Manual.~--- Intel Corporation, 2016.

\bibitem{s6} Intel\textregistered Intrinsics Guide. URL: https://software.intel.com/sites/landingpage/IntrinsicsGuide/

\end{thebibliography}

%References
\selectlanguage{english}
\begin{thebibliography}{99}
\selectlanguage{russian}

\bibitem{s1} \textit{Alekseev E.\,K., Popov V.\,O., Prokhorov A.\,S., Smyshlyaev S.\,V., Sonina L.\,A.} On the performance of one perspective LSX-based block cipher
// Mathematical Aspects of Cryptography.~--- 2015.~ --- V.~6, N.~2.~ --- P.~6--17.

\bibitem{s2}  \textit{Borodin M.\,A., Rybkin A.\,S.} High-Speed Software Implementation of Kuznyetchik block cipher.~--- Information Security Problems. Computer Systems~--- 2014.~ ---
N.~3 ---P.~67-73.

\bibitem{s3} \textit{Rybkin A.\,S.} On software implementation of Kuznyechik on Intel CPUs  // Mathematical Aspects of Cryptography.~--- 2018.~--- V.~9, N.~1.~--- P.~117--127.

\bibitem{s4} Intel\textregistered 64 and IA-32 Architectures Optimization Reference Manual.~--- Intel Corporation, 2016.

\bibitem{s5} Intel\textregistered 64 and IA-32 Architectures Software Developer's Manual.--- Intel Corporation, 2016.

\bibitem{s6} Intel\textregistered Intrinsics Guide. URL: https://software.intel.com/sites/landingpage/IntrinsicsGuide/


\end{thebibliography}
\selectlanguage{russian}

\begin{flushright}
 \textit{Поступила в редакцию дд.мм.гггг.}
\end{flushright} 
